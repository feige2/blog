<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>新博客，新开始</title>
    <url>/blog/2021-06-19-%E6%96%B0%E5%8D%9A%E5%AE%A2%EF%BC%8C%E6%96%B0%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<p>新家落成，欢迎常来做客！</p>
]]></content>
      <categories>
        <category>随想录</category>
      </categories>
      <tags>
        <tag>随想录</tag>
        <tag>闪念记</tag>
        <tag>闲言语</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 入门教程</title>
    <url>/blog/2021-06-27-Docker%E6%95%99%E7%A8%8B1/</url>
    <content><![CDATA[<p><img src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018020901.png" alt="docker"></p>
<h2 id="本文思维导图"><a href="#本文思维导图" class="headerlink" title="本文思维导图"></a>本文思维导图</h2><p><img src="/blog/xmind/Docker%E6%95%99%E7%A8%8B1.svg" alt="xmind-docker"><span id="more"></span></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h3><ul>
<li>应用容器引擎（Linux 容器 LXC的一种封装，提供简单易用的容器使用接口）</li>
<li>基于 Go 语言</li>
<li>开源 Apache2.0协议</li>
<li>两个版本：CE、EE</li>
<li>2013年发布</li>
</ul>
<p>Docker 将应用程序与该程序的依赖，打包在一个轻量级、可移植的文件里。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题，更重要的是容器性能开销极低。</p>
<p>Docker 的接口相当简单，用户可以方便地创建和使用容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
<h3 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h3><ul>
<li><p>环境配置的难题<br>安装一个软件，只有各种依赖（操作系统的设置、各种库和组件）的安装都正确，才能正常运行。而且每换一台机器，就要重来一次。</p>
<ul>
<li>解决方案：软件带环境安装</li>
</ul>
</li>
<li><p>Docker VS 虚拟机</p>
<ul>
<li>Docker 是进程级别的隔离（沙箱机制），而非模拟完整操作系统</li>
<li>启动快</li>
<li>冗余步骤少</li>
<li>资源占用少</li>
<li>体积小</li>
</ul>
</li>
</ul>
<h3 id="用途和应用场景"><a href="#用途和应用场景" class="headerlink" title="用途和应用场景"></a>用途和应用场景</h3><ul>
<li>提供一次性的环境</li>
<li>提供弹性的云服务</li>
<li>组建微服务架构</li>
<li>……</li>
</ul>
<h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h3><p>Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</p>
<p>Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件（容器模板），才能生成 Docker 容器。同一个 image 文件，可以生成多个同时运行的容器实例。</p>
<p>image 是通用的跨平台二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。</p>
<h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。</p>
<p>容器可以被创建、启动、停止、删除、暂停等。</p>
<h3 id="仓库（Respository）"><a href="#仓库（Respository）" class="headerlink" title="仓库（Respository）"></a>仓库（Respository）</h3><p>仓库可看成一个代码控制中心，用来保存镜像。</p>
<p>Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。</p>
<p>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p>
<h3 id="Docker-架构图（C-S-架构）"><a href="#Docker-架构图（C-S-架构）" class="headerlink" title="Docker 架构图（C/S 架构）"></a>Docker 架构图（C/S 架构）</h3><p><img src="https://www.runoob.com/wp-content/uploads/2016/04/576507-docker1.png" alt="Docker架构图"></p>
<ul>
<li>Docker 客户端(Client)<ul>
<li>Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</li>
</ul>
</li>
<li>Docker 主机(Host)<ul>
<li>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</li>
</ul>
</li>
<li>Docker Machine<ul>
<li>Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</li>
</ul>
</li>
</ul>
<h2 id="安装和换源"><a href="#安装和换源" class="headerlink" title="安装和换源"></a>安装和换源</h2><h3 id="Ubuntu-16-0-4"><a href="#Ubuntu-16-0-4" class="headerlink" title="Ubuntu 16.0.4"></a>Ubuntu 16.0.4</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用官方脚本自动安装</span></span><br><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组</span></span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 docker 服务</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 换源</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）：\n&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查加速器是否生效</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p>
<ul>
<li>科大镜像：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn/</a></li>
<li>网易：<a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com/</a></li>
<li>阿里云：https://&lt;你的ID&gt;.mirror.aliyuncs.com</li>
<li>七牛云加速器：<a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></li>
</ul>
<h3 id="其他操作系统"><a href="#其他操作系统" class="headerlink" title="其他操作系统"></a>其他操作系统</h3><ul>
<li>MacOS</li>
<li>Windows</li>
<li>CentOS</li>
<li>……</li>
</ul>
<blockquote>
<p>参考官方文档或自行搜索</p>
</blockquote>
<h2 id="Image-文件"><a href="#Image-文件" class="headerlink" title="Image 文件"></a>Image 文件</h2><h3 id="docker-image-ls"><a href="#docker-image-ls" class="headerlink" title="docker image ls"></a>docker image ls</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure>

<h3 id="docker-image-rm"><a href="#docker-image-rm" class="headerlink" title="docker image rm"></a>docker image rm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image rm [imageName]</span><br></pre></td></tr></table></figure>

<h3 id="docker-image-pull"><a href="#docker-image-pull" class="headerlink" title="docker image pull"></a>docker image pull</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从仓库拉取 image 文件。</span></span><br><span class="line">$ docker image pull [imageName]</span><br></pre></td></tr></table></figure>

<h2 id="容器文件"><a href="#容器文件" class="headerlink" title="容器文件"></a>容器文件</h2><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</p>
<p>一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p>
<h3 id="docker-container-ls"><a href="#docker-container-ls" class="headerlink" title="docker container ls"></a>docker container ls</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">$ docker container ls</span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">$ docker container ls --all</span><br></pre></td></tr></table></figure>

<h3 id="docker-container-run"><a href="#docker-container-run" class="headerlink" title="docker container run"></a>docker container run</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">$ docker container run [imageName]</span><br></pre></td></tr></table></figure>
<p>docker container run命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。</p>
<h3 id="docker-container-kill"><a href="#docker-container-kill" class="headerlink" title="docker container kill"></a>docker container kill</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 终止容器运行</span></span><br><span class="line">$ docker container <span class="built_in">kill</span> [containID]</span><br></pre></td></tr></table></figure>

<h3 id="docker-container-rm"><a href="#docker-container-rm" class="headerlink" title="docker container rm"></a>docker container rm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除容器实例</span></span><br><span class="line">$ docker container rm [containerID]</span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile-文件"><a href="#Dockerfile-文件" class="headerlink" title="Dockerfile 文件"></a>Dockerfile 文件</h2><p>它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p>
<h3 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure>
<p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.4</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install --registry=https://registry.npm.taobao.org</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> node demos/01.js</span></span><br></pre></td></tr></table></figure>
<ul>
<li>FROM node:8.4：<ul>
<li>该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。</li>
</ul>
</li>
<li>COPY . /app：<ul>
<li>将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。</li>
</ul>
</li>
<li>WORKDIR /app：<ul>
<li>指定接下来的工作路径为/app。</li>
</ul>
</li>
<li>RUN npm install：<ul>
<li>在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li>
</ul>
</li>
<li>EXPOSE 3000：<ul>
<li>将容器 3000 端口暴露出来， 允许外部连接这个端口。</li>
</ul>
</li>
<li>CMD node demos/01.js：<ul>
<li>它表示容器启动后自动执行node demos/01.js。</li>
</ul>
</li>
</ul>
<p>RUN命令与CMD命令的区别在哪里？</p>
<ul>
<li>RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。</li>
<li>一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。</li>
</ul>
<h3 id="创建-Image-文件"><a href="#创建-Image-文件" class="headerlink" title="创建 Image 文件"></a>创建 Image 文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image build -t koa-demo .</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker image build -t koa-demo:0.0.1 .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果运行成功，就可以看到新生成的 image 文件</span></span><br><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure>

<h3 id="生成并运行容器"><a href="#生成并运行容器" class="headerlink" title="生成并运行容器"></a>生成并运行容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br><span class="line"><span class="comment"># 指定了CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令。</span></span><br><span class="line">$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure>
<ul>
<li>-p参数：<ul>
<li>容器的 3000 端口映射到本机的 8000 端口。</li>
</ul>
</li>
<li>-it参数：<ul>
<li>容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li>
</ul>
</li>
<li>koa-demo:0.0.1：<ul>
<li>image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li>
</ul>
</li>
<li>/bin/bash：<ul>
<li>容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li>
</ul>
</li>
</ul>
<h2 id="发布-Image-文件"><a href="#发布-Image-文件" class="headerlink" title="发布 Image 文件"></a>发布 Image 文件</h2><p>首先，去 hub.docker.com 或 cloud.docker.com 注册一个账户。然后，用下面的命令登录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure>
<p>接着，为本地的 image 标注用户名和版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1</span><br></pre></td></tr></table></figure>
<p>也可以不标注用户名，重新构建一下 image 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image build -t [username]/[repository]:[tag] .</span><br></pre></td></tr></table></figure>
<p>最后，发布 image 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image push [username]/[repository]:[tag]</span><br></pre></td></tr></table></figure>
<p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><h3 id="docker-container-start"><a href="#docker-container-start" class="headerlink" title="docker container start"></a>docker container start</h3><p>前面的docker container run命令是新建容器，每运行一次，就会新建一个容器。如果希望重复使用容器，就要使用docker container start命令，它用来启动已经生成、已经停止运行的容器文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container start [containerID]</span><br></pre></td></tr></table></figure>

<h3 id="docker-container-stop"><a href="#docker-container-stop" class="headerlink" title="docker container stop"></a>docker container stop</h3><p>前面的docker container kill命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而docker container stop命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container stop [containerID]</span><br></pre></td></tr></table></figure>
<p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p>
<h3 id="docker-container-logs"><a href="#docker-container-logs" class="headerlink" title="docker container logs"></a>docker container logs</h3><p>docker container logs命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令查看输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container logs [containerID]</span><br></pre></td></tr></table></figure>

<h3 id="docker-container-exec"><a href="#docker-container-exec" class="headerlink" title="docker container exec"></a>docker container exec</h3><p>docker container exec命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container <span class="built_in">exec</span> -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure>

<h3 id="docker-container-cp"><a href="#docker-container-cp" class="headerlink" title="docker container cp"></a>docker container cp</h3><p>docker container cp命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container cp [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">阮一峰-Docker 入门教程</a><br><a href="https://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">阮一峰-Docker 微服务教程</a><br><a href="http://www.ruanyifeng.com/blog/2018/02/nginx-docker.html">阮一峰-Docker Nginx 容器教程</a><br><a href="https://www.runoob.com/docker/docker-tutorial.html">菜鸟教程-Docker 教程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Docker 教程</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
